import NextAuth from "next-auth";
// import GitHub from "next-auth/providers/github"
import google from "next-auth/providers/google";
import facebook from "next-auth/providers/facebook";
import Credentials from "next-auth/providers/credentials";
import { signInSchema } from "./validators/sign-in-schema";
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import { OAuth2Client } from "google-auth-library";
import { db } from "./db";
const googleAuthClient = new OAuth2Client(process.env.NEXT_PUBLIC_GOOGLE_ID);
const adapter = DrizzleAdapter(db);
export const { auth, handlers, signIn, signOut } = NextAuth({
  pages: {
    signIn: "/login",
  },
  adapter: adapter,

  providers: [
    google,
    facebook,
    Credentials({
      // The id of this credential provider. It's important to give an id because, in frontend we don't want to
      // show anything about this provider in a normal login flow
      id: "googleonetap",
      // A readable name
      name: "google-one-tap",

      // This field define what parameter we expect from the FE and what's its name. In this case "credential"
      // This field will contain the token generated by google
      credentials: {
        credential: { type: "text" },
      },
      // This where all the logic goes
      authorize: async (credentials) => {
        // The token given by google and provided from the frontend
        const token = credentials.credential as string;
        // We use the google library to exchange the token with some information about the user
        const ticket = await googleAuthClient.verifyIdToken({
          // The token received from the interface
          idToken: token,
          // This is the google ID of your application
          audience: process.env.NEXT_PUBLIC_GOOGLE_ID,
        });
        const payload = ticket.getPayload(); // This is the user

        if (!payload) {
          throw new Error("Cannot extract payload from signin token");
          return null;
        }

        const {
          email,
          sub,
          given_name,
          family_name,
          email_verified,
          picture: image,
        } = payload;

        // If for some reason the email is not provided, we cannot login the user with this method
        if (!email) {
          throw new Error("Email not available");
          // return null;
        }
        if (!adapter) {
          throw new Error("Adapter not available");
          // return null;
        }
        // Let's check on our DB if the user exists
        let user =
          adapter.getUserByEmail && (await adapter.getUserByEmail(email));

        // If there's no user, we need to create it
        if (!user) {
          user =
            adapter.createUser &&
            (await adapter.createUser({
              id: sub,
              name: [given_name, family_name].join(" "),
              email,
              image,
              emailVerified: email_verified ? new Date() : null,
            }));
        }

        // Let's also retrieve any account for the user from the DB, if any
        const account =
          user &&
          adapter.getUserByAccount &&
          (await adapter.getUserByAccount({
            provider: "google",
            providerAccountId: sub,
          }));

        // In case the account is not yet present on our DB, we want to create one and link to the user
        if (!account && user) {
          adapter.linkAccount &&
            (await adapter.linkAccount({
              userId: user.id,
              provider: "google",
              providerAccountId: sub,
              accessToken: null,
              accessTokenExpires: null,
              refresh_token: undefined,
              type: "oauth",
            }));
        }
        // We can finally returned the retrieved or created user
        return user || null;
      },
    }),
    Credentials({
      id: "googleonetap",
      // A readable name
      name: "google-one-tap",
      credentials: {
        email: {},
        password: {},
      },
      authorize: async (credentials) => {
        let user = {};
        const { email, password } = await signInSchema.parseAsync(credentials);
        // logic to salt and hash password
        // const pwHash = saltAndHashPassword(credentials.password)

        // logic to verify if user exists
        // user = await getUserFromDb(credentials.email, pwHash)

        if (!user) {
          // No user found, so this is their first attempt to login
          // meaning this is also the place you could do registration
          throw new Error("User not found.");
        }

        // return user object with the their profile data
        return user;
      },
    }),
  ],

  callbacks: {
    jwt({ token, user }) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    session({ session, user }) {
      session.user.id = user.id;
      return session;
    },
  },
});
export type {
  Account,
  DefaultSession,
  Profile,
  Session,
  User,
} from "@auth/core/types";
export type { AdapterSession } from "next-auth/adapters";
